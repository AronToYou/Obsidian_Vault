# Tasks
- [x] `package-lock.json` (`requirements.txt` & `.dockerignore`) ✅ 2025-08-19
- [x] difference between apk & apt (& yum) ✅ 2025-08-19
	- [x] apt pin ✅ 2025-08-19
- [x] `useradd` + `USER app` ✅ 2025-08-19
	- [x] `RUN useradd -m -u 10001 appuser` ✅ 2025-08-19
	- [x] `USER appuser` # Drop privileges? ✅ 2025-08-19
- [x] remove build deps `rm -rf /var/lib/apt/lists/*`!? ✅ 2025-08-19
- [x] other `--no-install-recommends` (minimize surface) ✅ 2025-08-19
	- [x] add labels (org.opencontainers.image.) ✅ 2025-08-19
	- [x] SBOM (syft) ✅ 2025-08-19
	- [x] scan as part of CI (trivy) ✅ 2025-08-19
- [x] Commands ✅ 2025-08-19
	- [x] `WORKDIR` ✅ 2025-08-19
	- [x] `COPY` ✅ 2025-08-19
	- [x] `FROM` where does it install to? ✅ 2025-08-19
- [x] stale cache? ✅ 2025-08-19
- [x] python pip wheel ✅ 2025-08-19
- [x] why only copy node_modules, what is contained in there? ✅ 2025-08-19



# Notes
## Docker
### Docker commands
- `{dockerfile}WORKDIR /app` : sets working directory for subsequent instructions (`{sh}cd` for container runtime)
- `{dockerfile}COPY <build-context> ... <image-destination>`
	- confined to build context from `{sh}docker build .`
	- `{dockerfile}COPY . /app` : copies entire project folder (host) to `/app/` inside image
		- `.dockerignore` : used to exclude files/folders from above
	- `{dockerfile}COPY --from=<image>:<tag> /path/to/bin /usr/local/bin/..`
	- Any source directory changes invalidate layer cache
		- `{dockerfile}COPY package.json package-lock.json ./`
		- `{dockerfile}RUN npm ci --omit=dev`
		- `{dockerfile}COPY . .`
- `{dockerfile} ADD <src>... <dst>` : like `{dockerfile}COPY` except:
	- also accepts URLs, 
	- tar archives, 
	- and absolute paths outside of build context
- `{dockerfile}FROM <image>[:<tag>] [AS <name>]`
	- `{dockerfile}FROM ubuntu@sha256:abcdka32kon42... AS builder`
	- `{dockerfile}FROM nginx:1.27`
	- `{dockerfile}COPY --from=builder /app/dist /usr/share/nginx/html`
- containers run as `root` by default,
	- `{dockerfile}USER appuser` : switches runtime user (and possibly group)
	- more modern: use 
		- `{dockerfile}COPY --chown=<UID>:<GID> . /app`
		- `USER <UID>:<GID>`
- `{dockerfile}RUN apt-get update && \`
	- `{sh}apt-get install -y --no-install-recommends ffmpeg && \`
	- `{sh}rm -rf /var/lib/apt/lists/*`
- `{dockerfile}ARG BASE=python:3.12-slim`
	- `{dockerfile}FROM ${BASE}`
	- `{sh}docker build --build-arg BASE=python3.13-slim`
- `{dockerfile}ENTRYPOINT ["echo", "Hello"]`
	- `{sh}docker run myapp World` -> `{sh}echo Hello World`
	- overridden by `{sh}docker run --entrypoint`
- `{dockerfile}CMD ["node", "server.js"]`
	- overridden by `{sh}docker run myapp echo Hello World`
	- if `{dockerfile}ENTRYPOINT` is used, then `{dockerfile}CMD` defines default (overridable) arguments

### Docker tips
- Layers:
	- each instruction produces a new layer (`{dockerfile}FROM`, `{dockerfile}RUN`, `{dockerfile}COPY`, `{dockerfile}ADD`, etc.)
	- Cached : if instruction and its context are unchanged, Docker reuses layer/doesn't rebuild
	- Stacked : Final image is a union filesystem of all layers
- CI/CD
	1. `{dockerfile}LABEL org.opencontainers.image.title="MyApp"`
		- `{dockerfile}LABEL .version="1.2.3"`
		- `{dockerfile}LABEL .source="https://githib.com/myorg/myapp"`
		- `{dockerfile}LABEL .licenses="MIT"`
	2. (SBOM) - Software Bill Of Materials (generated from an image by e.g. `syft`)
	3. Vulnerability Scanning - scan image for CVEs (with `trivy` or `grype`)
- (7.) `{dockerfile}ENTRYPOINT ["/usr/bin/tini", "--"]`
	- `{dockerfile}CMD ["node", "server.js"]`
- (7.) if supervising multiple daemons,
	- wire a supervisor (s6-overlay, supervisord)
	- and stop signals `STOPSIGNAL SIGTERM`, 
	- and a `{dockerfile}HEALTHCHECK --interval=30s --timeout=5s --retries=5 \`
		- `{dockerfile}CMD node healthcheck.js || exit 1`
- (8.) keep config in `/etc/<app>`
- (9.) smoke test: `{sh}docker run <image> --version`
- `{dockerfile}RUN apk add --no-cache`
	- equal to prepending `{sh}apk update` and appending `{sh}rm -rf /var/cache/apk/*`
- `{dockerfile}RUN pip install --no-cache-dir <package>`

### Steps
1. CLI tools, daemons/services, & supervisor
2. OS packages, language runtimes, standalone binaries, services
3. Base Image
4. Multi-Stage
5. Layering & Caching (most volatile last & lockfiles/`.dockerignore`)
6. Security & Reproducibility (pin versions, non-root, minimize surface)
7. Process Model & Startup
8. Configuration & Data (expose ports, declare `VOLUME`)

## Node
- `package-lock.json` : full dependency tree, versions, SHA512s, & sources! (produced by `{sh}npm install`)
	- `{sh}npm ci --omit=dev` to reproduce
- `package.json` : Project info (name, version, description, scripts) & loose top-level dependencies
- `node-gyp` : builds Node.js Addons, or native Node.js Modules written in C/C++
- `{sh}npm test`
- `{cpp}node_modules/` : contains project's dependencies installed by `{sh}npm` (fully resolved dependency tree)
```node title:serve-react
const handler = require('serve-handler');
const http = require('http');

const server = http.createServer((request, response) => {
  // You pass two more arguments for config and middleware
  // More details here: https://github.com/vercel/serve-handler#options
  return handler(request, response);
});

server.listen(3000, () => {
  console.log('Running at http://localhost:3000');
});
```

## Linux
- Alpine - `alpine:3.20` (~5 MB) (security-focused, lightweight)
	- glibc -> musl (`gcompat`, `alpine-glibc`)
	- apt -> apk
	- `bash` -> BusyBox `sh` (`{sh}apk add bash`)
	- no man pages, slow Python/Node builds
		- Node runs fine on `musl`
		- check whether used native modules publish `musl` prebuilds (README/CI)
- Ubuntu - `ubuntu:24.04` (~29 MB)
	- `{cpp}/etc/apt/sources.list` : Repos, each entry contains
		- protocol & location | distribution | sections/components
		- `{cpp}deb http://deb.debian.org/debian bookworm main contrib non-free`
		  `{cpp}deb http://security.debian.org/debian-security bookworm-security main`
		  `{cpp}deb http://deb.debian.org/debian bookworm-updates main`
	- `{cpp}/etc/apt/sources.list.d/` : extra repo definitions
		- `{cpp}/etc/apt/sources.list.d/docker.list`
		- `{cpp}deb [arch=amd64] https://download.docker.com/linux/debian bookworm stable`
	- `{cpp}/var/lib/apt/lists/` : local cache of package index files (from `{sh}apt update`)
	- `useradd -m -u 10001 appuser` : create user with username `appuser`, 
		- make home directory `/home/appuser`, 
		- assign UID `10001`
- Debian - `debian:bookworm-slim` (~22 MB)
- CentOS - `centos:7` (~200 MB) (enterprise)
	- `apt` -> `yum`/`dnf`
# Examples
## docker-compose.yml
```yml
# docker-compose.yml (preferred pattern)
services:
  web:
    image: yourorg/yourapp:latest
    ports: ["8080:8080"]
    depends_on: ["nginx"]
  nginx:
    image: nginx:1.27-alpine
    volumes:
      - ./nginx.conf:/etc/nginx/nginx.conf:ro
    ports: ["80:80"]
```

## Dockerfile
### multi-stage
```dockerfile
# ---------- Stage 1: Node deps ----------
FROM node:22-bookworm AS node_deps
WORKDIR /opt/app
COPY package.json package-lock.json ./
RUN npm ci --omit=dev

# ---------- Stage 2: Python deps ----------
FROM python:3.12-slim-bookworm AS py_deps
WORKDIR /opt/app
COPY requirements.txt .
# Build wheels separately so we can copy only what we need later
RUN pip wheel --no-cache-dir --wheel-dir /wheels -r requirements.txt

# ---------- Stage 3: Fetch a standalone binary (ffmpeg) ----------
# Option A: install from apt in a throwaway stage
FROM debian:bookworm-slim AS ffmpeg_stage
RUN apt-get update && \
    apt-get install -y --no-install-recommends ffmpeg && \
    rm -rf /var/lib/apt/lists/*
# Option B: or COPY --from=jrottenberg/ffmpeg:6.1-ubuntu /usr/bin/ffmpeg /usr/bin/ffmpeg

# ---------- Stage 4: Final runtime ----------
FROM debian:bookworm-slim

# Security: create non-root user
RUN useradd -m -u 10001 appuser

# System packages your runtime actually needs
RUN apt-get update && apt-get install -y --no-install-recommends \
      ca-certificates curl tini \
    && rm -rf /var/lib/apt/lists/*

# Node runtime: copy only what you need (node itself comes from a package; here we just need node_modules)
# If you also need Node itself, consider installing node from nodesource or copying from node image:
# COPY --from=node:22-bookworm /usr/local/bin/node /usr/local/bin/node
# COPY --from=node:22-bookworm /usr/local/lib/node_modules /usr/local/lib/node_modules
# For simplicity, assume the base app runs via node provided separately or uses system's
WORKDIR /opt/app
COPY --from=node_deps /opt/app/node_modules ./node_modules
COPY package.json ./

# Python runtime: install from prebuilt wheels
COPY --from=py_deps /wheels /wheels
RUN python3 -m pip install --no-cache-dir /wheels/*

# ffmpeg binary
COPY --from=ffmpeg_stage /usr/bin/ffmpeg /usr/local/bin/ffmpeg

# Your application code (do this late for better caching)
COPY . .

# Drop privileges
USER appuser

# Healthcheck (adjust to your app)
HEALTHCHECK --interval=30s --timeout=5s --retries=5 \
  CMD node healthcheck.js || exit 1

# Handle PID 1 and signals cleanly
ENTRYPOINT ["/usr/bin/tini", "--"]
CMD ["node", "server.js"]
```

### alpine
```dockerfile
FROM node:22-alpine AS build
RUN apk add --no-cache python3 make g++
WORKDIR /app
COPY package.json package-lock.json ./
RUN npm ci
COPY . .
RUN npm run build

FROM node:22-alpine AS runtime
WORKDIR /app
COPY --from=build /app/dist ./dist
COPY package.json package-lock.json ./
# Optionally prune dev deps:
RUN npm ci --omit=dev
CMD ["node", "dist/server.js"]
```

### Node
```dockerfile
FROM node:22-slim

# Set working dir inside container
WORKDIR /usr/src/app

# Copy only dependency manifests first
COPY package*.json ./

# Install deps (cached if manifests unchanged)
RUN npm ci --omit=dev

# Now copy the rest of the code
COPY . .

# Default runtime working directory = /usr/src/app
CMD ["node", "server.js"]
```